# day08

배열의 복사
	종류 ]
		1. 얕은 복사
			==> 주소만 복사하는 방법
			
			특징 ]
				데이터는 공유하기 때문에 
				한곳에서 수정하면 다른 곳에서도 수정된 내용을 사용
				
			방법 ]
				int[] a = new int[5];
				....
				
				int[] b;
					이 변수는 배열의 주소를 기억할 변수를 만들어준 결과...
					b 안에는 데이터는 기억할 수 없고
					오직 같은 Heap 타입의 int[] 의 주소만 기억할 수 있다.
					
				b = a;	==> 얕은 복사가 된다. a에서 만든 배열을 같이 공유하게 된다.
				
			참고 ]
				얕은 복사는 
				지역변수는 그 지역에서만 사용할 수 있으므로
				다른지역에서 Heap 영역의 데이터를 사용할 목적으로 
				많이 사용되는 방법
				
			
		2. 깊은 복사
			==> 데이터를 복사하는 방법
			
				데이터가 복사 되었다는 것은 
				Heap 영역에 다른 인스턴스(new 명령으로 생겨난 결과물)가 만들어졌다는 것이므로
				변수가 기억하는 주소가 달라지게 되므로
				***
				복사된 데이터는 독립적으로 사용된다.
				
			방법 ]
				명령을 사용해서 처리하면 된다.
				
				
				System.arraycopy(#1, #2, #3, #4, #5);
					
					#1	-	원본배열의 주소
					#2	-	원본배열의 복사를 시작할 위치
					#3	-	복사받을 배열의 주소
					#4	- 	복사받을 배열의 시작위치값
					#5	- 	복사받을 데이터의 갯수
					
----------------------------------------------------------------------------------------------
배열의 단점
	1. 한번 배열의 크기를 정하면 크기 조절이 불가능하다.
		
		예 ]
			int[] no1 = new int[10];
			....
			// 작업을 하다가 10개를 추가해야되는 경우
			int[] no2 = new int[20];
			
			// 데이터 복사
			System.arraycopy(no1, 0, no2, 0, 10);
			// 추가데이터 입력
			no2[10] = ???;
			no2[11] = ???;
			
	2. 같은 형태의 데이터만 관리할 수 있다.
		==> 주소는 Heap 타입에 의해서 결정이되고
			Heap Type이 다르면 사용할 수 없다.
			
			예 ]
				
				int[] a = new int[10];
				
				float[] b;
				
				b = a; ==> 절대로 아니되옵니다.
				
----------------------------------------------------------------------------------------------

String 배열

	참고 ]
		String 역시 참조형 타입이다.
		
		String str = "Hong";
		
		str에는 데이터 자체의 주소가 기억되고
		
		String str = new String("Hong");
		라고 변수를 만들면
		변수는 Heap에 만들어진 인스턴스의 주소를 기억하고
		인스턴스가 데이터의 주소를 기억한다.
		
	------------------------------------------------------------------------------
	String 배열 만들기
	
		String[] str ; // 배열변수 선언, 데이터를 사용할 준비
		str = new String[5];
		==> 데이터가 초기화가 안되어있는 상태
			아직 각 인덱스가 비어있는 상태(데이터가 결정이 안되어있는 상태)
			
		str[0] = "Hong";
		str[1] = "Dooly";
		==>  위처럼 데이터 공간까지 만들어 줘야 한다.
		
		String 배열도 초기화가 가능하다.
		
		String[] names = {"둘리", "제니", "리사", "로제", "지수"};
		
	----------------------------------------------------------------------------------
	참고 ]
		문자열도 필요에 따라서 char[] 형태로 변환해서 사용할 수 있다.
		
		방법 ]
			toCharArray();
			
		예 ]
			String name = "jenie";
			
			char[] ch = name.toCharArray();
			
			ch[0] ==> j
			ch[1] ==> e
			
	----------------------------------------------------------------------------------
	
	참고 ]
		String 클래스에서 자주 사용되는 함수
		
			1. charAt(위치값)
				==> 해당 위치의 문자를 알려준다.
			2. length()
				==> 문자열의 길이를 알려준다.
			3. substring()
				==> 문자열 중에서 원하는 문자열만 따로 뽑아서 반환해준다.
				
				형식 1 ]
					substring(시작위치);
					==> 시작위치에서부터 맨 마지막까지 모두 추출해준다.
					
				형식 2 ]
					substring(시작위치, 종료위치);
					==> 시작위치에서부터 종료위치 이전 문자까지 추출해준다.
					
					**
					주의 ]
						시작위치는 0부터 카운트해서 지정한다.
						종료위치는 1부터 카운트 해서 지정한다.
					
					
			4. equals()
				==> 문자열의 데이터 자체가 같은지 비교해서 논리값으로 반환해주는 함수
	-----------------------------------------------------------------------------------------
				
2차원 배열
	==> 1차원배열을 관리하는 배열
		==> 배열안에 다시 배열이 들어있는 형태
			(정확히는 배열안에 1차원 배열의 주소가 기억된다.)
			
	2차원배열 만드는 방법
		1. 배열 주소를 기억할 변수를 만든다.
			==> Heap 영역에 있는 데이터는 주소를 알아야 사용하기 때문이다.\
			
			방법 ]
				데이터타입[][]		변수이름;
				==> [] 가 1개이면 1차원 배열이 되고
					2개이면 2차원 배열 
					3개면 3차원배열
					....
					
			예 ]
				int[][] num;
				
				num = new int[5]; ===> X : heap type이 달라서 안된다.
				
				
		2. 1차원 배열을 몇개를 관리할 지를 결정하고
			1차원 배열의 주소를 기억할 메모리를 만든다.
			
			방법 ]
				new 데이터타입[갯수][];
				==> 갯수는 1차원 배열의 갯수를 지정한다.
				
			예 ]
				num = new int[5][];
				
				
		3. 실제 정수를 관리하는 1차원배열의 길이를 결정하고
			1차원 배열의 주소를 기억할 메모리를 만든다.
			
			방법 ]
				
				new 	데이터타입[갯수];
				
			예 ]
				num[0] = new int[3];
				
------------------------------------------------------------------------------------------

	참고 ]
		2차원 배열도 사각형 형태의 배열을 만들 수 있다.
		
		형식 ]
			데이터타입[][] 		변수 = new 		데이터타입[행수][열수];
			
		예 ]
			int[][] num = new int[5][3];
			==> 정수 3개를 관리하는 배열 5개를 관리하는 배열
			
		주의 ]
			이해를 돕기위해서 사각형으로 설명하지만
			실제로는 별도의 메모리공간을 차지하는 배열이 만들어지고 
			그 배열을 관리하는 배열이 다시 만들어진다.
	
	참고 ]
		2차원 배열도 초기화가 가능하다.
		
		방법 ]
			
			int[] num = {데이터1, 데이터2, ....}; // 데이터의 갯수만큼 만들어지고 입력된 데이터로 초기화가 된다.
			
			int[][] num = {{1,2}, {3, 4, 5}, {6, 7, 8, 9}};
			==>
				여기서도 배열의 갯수를 지정할 수는 없다.
			
------------------------------------------------------------------------------------------

		